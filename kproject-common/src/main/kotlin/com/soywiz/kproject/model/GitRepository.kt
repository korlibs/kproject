package com.soywiz.kproject.model

import com.soywiz.kproject.git.*
import com.soywiz.kproject.util.*
import org.eclipse.jgit.api.*
import org.eclipse.jgit.lib.*
import java.io.*
import java.security.*

data class GitRepository(val repo: String) {
    val httpsRepo = when {
        repo.startsWith("git@") -> repo.substringAfter("git@").replace(':', '/')
        else -> repo
    }
    val cachePath: String = PathInfo(httpsRepo.removePrefix("https://").substringAfter("://").replace(':', '/').removeSuffix(".git")).fullPath

    companion object {
        fun fromGithub(org: String, name: String): GitRepository = GitRepository("https://github.com/$org/$name.git")
    }

    fun getCacheFolder(): File = File(getKProjectDir(), "clones/$cachePath")

    fun getGit(): Git {
        val gitFolder = File(getCacheFolder(), "/__git__")
        return when {
            gitFolder.exists() -> Git.open(gitFolder)
            else -> Git.cloneRepository()
                    .setProgressMonitor(TextProgressMonitor(PrintWriter(System.out)))
                    .setURI(httpsRepo)
                    .setDirectory(gitFolder)
                    //.setBare(true)
                    .call()
        }.also {
            it.repository.config
                .setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_AUTOCRLF, false)
        }
    }
}

data class GitRepositoryWithPathAndRef(val repo: GitRepository, val path: String, val ref: String) {
    data class Content(
        /**
         * [File] with a path to a zip file with the contents
         */
        val zipFile: File,
        /**
         * SHA-1 of the [ref] to check for sanity
         */
        val commitId: String,
        /**
         * Hash is the SHA-256 of a ByteArray consisting in all the files in the path with normalized paths (and autocrlf=false):
         *
         * <full/path1>\n<size1>\n<content1><full/path2>\n<size2>\n<content2>...
         *
         * Generated by [generateStableZipContent]
         */
        val hash: String,
    )

    fun getContent(clean: Boolean = false): Content {
        val gitFolder = repo.getCacheFolder()["__checkouts__"][PathInfo(path).fullPath.trim('/')]
        //println("gitFolder=$gitFolder")
        gitFolder.mkdirs()
        val checkoutZip = gitFolder[ref.pathInfo.fullPath + ".zip"]
        val checkoutBin = gitFolder[ref.pathInfo.fullPath + ".bin"]
        val checkoutHash = gitFolder[ref.pathInfo.fullPath + ".hash"]
        val commitId = gitFolder[ref.pathInfo.fullPath + ".cid"]

        if (clean) {
            checkoutZip.delete()
            checkoutBin.delete()
            checkoutHash.delete()
        }

        if (!checkoutZip.exists() || !commitId.exists()) {
            val git = repo.getGit()
            if (!git.checkRefExists(ref)) {
                git.pull()
                    .setProgressMonitor(TextProgressMonitor(PrintWriter(System.out)))
                    .call()
            }
            if (!git.checkRefExists(ref)) {
                error("Can't find ref='$ref' in $repo")
            }
            checkoutZip.writeBytes(repo.getGit().archiveZip(path, ref))
            commitId.writeText(git.repository.resolve(ref).name)
        }
        if (!checkoutBin.exists()) {
            checkoutBin.writeBytes(generateStableZipContent(checkoutZip.readBytes()))
        }
        if (!checkoutHash.exists()) {
            checkoutHash.writeText(MessageDigest.getInstance("SHA-256").digest(checkoutBin.readBytes()).hex())
        }
        return Content(checkoutZip, commitId.readText(), checkoutHash.readText())
    }
}
